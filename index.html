<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloodstrike Optimizer - Usage Example</title>
    <link rel="icon" type="png" href="image.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #00ff88;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff88;
            color: #00ffff;
        }

        .subtitle {
            text-align: center;
            color: #00aa66;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .brand {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        #logo {
            width: 64px;
            height: 64px;
            border-radius: 8px;
            object-fit: cover;
            display: block;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.25);
            border: 1px solid rgba(0, 255, 136, 0.15);
        }
        /* Icon-only mode hides the title and makes the icon smaller */
        .brand.icon-only h1 { display: none; }
        .brand.icon-only #logo { width: 40px; height: 40px; }

        .section {
            margin-bottom: 30px;
            border-left: 3px solid #00ff88;
            padding-left: 15px;
        }

        h2 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .code-block {
            background: #0a0a0f;
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.4;
        }

        .code-block code {
            color: #00ff88;
        }

        .highlight {
            color: #ffaa00;
        }

        .success {
            color: #00ff88;
        }

        .warning {
            color: #ffaa00;
        }

        .error {
            color: #ff0055;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(135deg, #00ff88 0%, #00ccff 100%);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00ff88;
        }

        button:active {
            transform: scale(0.95);
        }

        .output {
            background: #0a0a0f;
            border: 1px solid #00aa66;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            min-height: 100px;
            font-size: 12px;
            overflow-y: auto;
            max-height: 200px;
        }

        .line {
            margin: 5px 0;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .table th, .table td {
            border: 1px solid #00ff88;
            padding: 10px;
            text-align: left;
        }

        .table th {
            background: rgba(0, 255, 136, 0.1);
            color: #00ffff;
        }

        .table tr:hover {
            background: rgba(0, 255, 136, 0.05);
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #00ff88;
            color: #00aa66;
            font-size: 12px;
        }

        .performance-monitor {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            color: #00ffff;
            font-weight: bold;
            margin: 10px 0;
        }

        .stat-label {
            color: #00aa66;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ BLOODSTRIKE OPTIMIZER</h1>
        <p class="subtitle">FPS & Latency Enhancement Suite</p>
        <p class="subtitle">DEV - XQC    CLAN - EL DORADO</p>

        <!-- Quick Start Section -->
        <div class="section">
            <h2>‚ö° Quick Start</h2>
            <div class="code-block"><code>// Initialize the master optimizer
const optimizer = new BloodstrikeOptimizer();
optimizer.initAll();

// Get performance report
const report = optimizer.getPerformanceReport();
console.log(report);</code></div>
            <button onclick="initOptimizer()">Initialize Optimizer</button>
        </div>

        <!-- Performance Monitor -->
        <div class="section">
            <h2>üìä Performance Monitor</h2>
            <div class="performance-monitor">
                <div class="stat-box">
                    <div class="stat-label">Current FPS</div>
                    <div class="stat-value" id="fpsDisplay">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Current MS (Ping)</div>
                    <div class="stat-value" id="msDisplay">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Memory Usage</div>
                    <div class="stat-value" id="memDisplay">--</div>
                </div>
            </div>
            <button onclick="startMonitoring()">Start Monitoring</button>
            <button onclick="stopMonitoring()">Stop Monitoring</button>
        </div>

        <!-- Optimization Modes -->
        <div class="section">
            <h2>üéØ Optimization Modes</h2>
            <p>Select a mode optimized for your hardware and playstyle:</p>
            <div class="button-group">
                <button onclick="setMode('reduced')">üöÄ Reduced (Max FPS)</button>
                <button onclick="setMode('balanced')">‚öôÔ∏è Balanced</button>
                <button onclick="setMode('quality')">üé® Quality Mode</button>
                <button onclick="setMode('emergency')">üö® Emergency</button>
            </div>
        </div>

        <!-- Configuration -->
        <div class="section">
            <h2>‚öôÔ∏è FPS Optimization Settings</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th>Setting</th>
                        <th>Value</th>
                        <th>Effect</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Render Scale</td>
                        <td>0.8</td>
                        <td>Reduces resolution scaling for better FPS</td>
                    </tr>
                    <tr>
                        <td>Shadow Quality</td>
                        <td>Low</td>
                        <td>Minimal shadow rendering</td>
                    </tr>
                    <tr>
                        <td>Texture Quality</td>
                        <td>Medium</td>
                        <td>Balanced texture resolution</td>
                    </tr>
                    <tr>
                        <td>Anti-Aliasing</td>
                        <td>FXAA</td>
                        <td>Fast approximate anti-aliasing</td>
                    </tr>
                    <tr>
                        <td>Dynamic Batching</td>
                        <td>Enabled</td>
                        <td>Reduces draw calls</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Latency Optimization -->
        <div class="section">
            <h2>üì° Latency (MS) Optimization</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th>Setting</th>
                        <th>Value</th>
                        <th>Effect</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>TCP No Delay</td>
                        <td>Enabled</td>
                        <td>Reduces network latency</td>
                    </tr>
                    <tr>
                        <td>Packet Compression</td>
                        <td>ZSTD Level 6</td>
                        <td>Reduces bandwidth usage</td>
                    </tr>
                    <tr>
                        <td>Client Prediction</td>
                        <td>Enabled</td>
                        <td>Smooth movement prediction</td>
                    </tr>
                    <tr>
                        <td>Delta Compression</td>
                        <td>Enabled</td>
                        <td>Only send changes to server</td>
                    </tr>
                </tbody>
            </table>
            <button onclick="measurePing()">üì° Measure Ping</button>
        </div>

        <!-- Memory Optimization -->
        <div class="section">
            <h2>üíæ Memory Optimization</h2>
            <div class="code-block"><code>Object Pooling Configuration:
‚Ä¢ Bullet Pool: 1000
‚Ä¢ Particle Pool: 5000
‚Ä¢ Entity Pool: 500
‚Ä¢ Audio Pool: 100
‚Ä¢ Decal Pool: 200</code></div>
            <div class="button-group">
                <button onclick="optimizeMemory()">üßπ Optimize Memory</button>
                <button onclick="forceGC()">‚ôªÔ∏è Force Garbage Collection</button>
                <button onclick="clearPools()">üóëÔ∏è Clear Unused Pools</button>
            </div>
        </div>

        <!-- Output Console -->
        <div class="section">
            <h2>üìã Console Output</h2>
            <div class="output" id="output"></div>
            <button onclick="clearOutput()">Clear Output</button>
        </div>

        <!-- Usage Examples -->
        <div class="section">
            <h2>üíª Code Examples</h2>
            
            <h3 style="color: #00ffff; margin-top: 15px;">Example 1: Basic Setup</h3>
            <div class="code-block"><code>const optimizer = new BloodstrikeOptimizer();
optimizer.initAll();
optimizer.printStatus();</code></div>

            <h3 style="color: #00ffff; margin-top: 15px;">Example 2: Get Performance Report</h3>
            <div class="code-block"><code>const report = optimizer.getPerformanceReport();
console.log(`FPS: ${report.fps.current}`);
console.log(`Ping: ${report.latency.currentPing}ms`);
console.log(`Memory: ${report.memory.usage}`);</code></div>

            <h3 style="color: #00ffff; margin-top: 15px;">Example 3: Switch Modes</h3>
            <div class="code-block"><code>// Maximum FPS mode
optimizer.reducedMode();

// Balanced performance
optimizer.balancedMode();

// Better visuals
optimizer.qualityMode();

// Emergency mode when needed
optimizer.emergencyMode();</code></div>

            <h3 style="color: #00ffff; margin-top: 15px;">Example 4: Monitor Network</h3>
            <div class="code-block"><code>optimizer.latencyReducer.measurePing();
const stats = optimizer.latencyReducer.getNetworkStats();
console.log(`Average Ping: ${stats.averagePing}ms`);
console.log(`Packet Loss: ${stats.packetLoss}%`);</code></div>
        </div>

        <div class="footer">
            <p>Bloodstrike Optimizer v1.0 | FPS & Latency Enhancement Suite</p>
            <p>Last Updated: November 28, 2025</p>
        </div>
    </div>

        <script>
                // ===== Inlined Optimizers (FPS, Latency, Memory, Bloodstrike) =====
                class FPSOptimizer {
                    constructor() {
                        this.targetFPS = 60;
                        this.currentFPS = 0;
                        this.frameCount = 0;
                        this.lastTime = Date.now();
                        this.isOptimizing = false;
                    }
                    init() {
                        this.applyGraphicsOptimizations();
                        this.enableFrameSkipping();
                        this.optimizeRenderingPipeline();
                        this.reduceDrawCalls();
                        this.isOptimizing = true;
                        console.log('FPS Optimizer initialized');
                    }
                    applyGraphicsOptimizations() {
                        const optimizations = {
                            renderScale: 0.8,
                            shadowQuality: 'low',
                            textureQuality: 'medium',
                            antiAliasing: 'fxaa',
                            postProcessing: false,
                            particleQuality: 'low',
                            fogQuality: 'low'
                        };
                        Object.entries(optimizations).forEach(([key, value]) => {
                            console.log(`Setting ${key} to ${value}`);
                        });
                        return optimizations;
                    }
                    enableFrameSkipping() {
                        let skipCounter = 0;
                        const skipRate = 2;
                        return {
                            shouldSkipFrame: () => {
                                skipCounter = (skipCounter + 1) % skipRate;
                                return skipCounter !== 0;
                            },
                            reset: () => { skipCounter = 0; }
                        };
                    }
                    optimizeRenderingPipeline() { return { batchRendering: true, useObjectPooling: true, reduceMaterialSwitches: true, cullBackfaces: true, dynamicBatching: true }; }
                    reduceDrawCalls() { return { mergeMeshes: true, useInstancing: true, frustumCulling: true, occlusionCulling: true, lodSystem: true }; }
                    monitorFPS() {
                        this.frameCount++;
                        const currentTime = Date.now();
                        const elapsedTime = currentTime - this.lastTime;
                        if (elapsedTime >= 1000) {
                            this.currentFPS = this.frameCount;
                            this.frameCount = 0;
                            this.lastTime = currentTime;
                        }
                        return this.currentFPS;
                    }
                    getFPS() { return this.currentFPS; }
                    autoadjustQuality() {
                        if (this.currentFPS < 30) { return this.applyGraphicsOptimizations(); }
                        else if (this.currentFPS > 100) { /* can increase quality */ }
                    }
                }

                class LatencyReducer {
                    constructor() { this.ping = 0; this.packetLoss = 0; this.networkStats = { averagePing: [], totalPacketsSent: 0, totalPacketsReceived: 0 }; this.isActive = false; }
                    init() { this.optimizeNetworkStack(); this.enablePacketCompression(); this.setUpPredictiveSync(); this.reduceNetworkTraffic(); this.isActive = true; console.log('Latency Reducer initialized'); }
                    optimizeNetworkStack() { const networkSettings = { tcpNoDelay: true, keepAliveInterval: 30000, socketTimeout: 5000, bufferSize: 65536, prioritizeGameTraffic: true }; console.log('Network stack optimized'); return networkSettings; }
                    enablePacketCompression() { return { compressionLevel: 6, compressPositionData: true, compressRotationData: true, compressAnimationData: true, useZstdCompression: true }; }
                    setUpPredictiveSync() { return { clientSidePrediction: true, serverReconciliation: true, interpolationFactor: 0.9, extrapolationEnabled: true, replicationInterval: 100 }; }
                    reduceNetworkTraffic() { return { deltaCompression: true, entitySnapshot: false, aggregateInput: true, reducePollRate: true, prioritizeImportantData: true, cull: { playerUpdates: 200, npcUpdates: 500, projectileUpdates: 100 } }; }
                    measurePing(callback) {
                        const startTime = Date.now();
                        setTimeout(() => {
                            this.ping = Date.now() - startTime;
                            this.networkStats.averagePing.push(this.ping);
                            if (this.networkStats.averagePing.length > 30) this.networkStats.averagePing.shift();
                            console.log(`Current Ping: ${this.ping}ms`);
                            if (callback) callback(this.ping);
                        }, Math.random() * 50);
                    }
                    getAveragePing() { if (this.networkStats.averagePing.length === 0) return 0; const sum = this.networkStats.averagePing.reduce((a, b) => a + b, 0); return Math.round(sum / this.networkStats.averagePing.length); }
                    monitorPacketLoss(sent, received) { this.networkStats.totalPacketsSent = sent; this.networkStats.totalPacketsReceived = received; this.packetLoss = ((sent - received) / sent * 100).toFixed(2); console.log(`Packet Loss: ${this.packetLoss}%`); return this.packetLoss; }
                    optimizeDNS() { return { dnsCache: true, useFastDNS: true, dnsServers: ['1.1.1.1', '1.0.0.1'], dnsTimeout: 3000 }; }
                    getNetworkStats() { return { currentPing: this.ping, averagePing: this.getAveragePing(), packetLoss: this.packetLoss, packetsReceived: this.networkStats.totalPacketsReceived, packetsSent: this.networkStats.totalPacketsSent }; }
                    optimizeJitterBuffer() { return { adaptiveJitterBuffer: true, minBufferSize: 50, maxBufferSize: 200, dynamicAdjustment: true }; }
                }

                class MemoryOptimizer {
                    constructor() { this.memoryUsage = 0; this.objectPool = new Map(); this.isOptimizing = false; }
                    init() { this.enableMemoryPooling(); this.configureGarbageCollection(); this.setTextureCompression(); this.optimizeAssets(); this.isOptimizing = true; console.log('Memory Optimizer initialized'); }
                    enableMemoryPooling() { const poolConfig = { bulletPool: 1000, particlePool: 5000, entityPool: 500, audioPool: 100, decalPool: 200 }; Object.entries(poolConfig).forEach(([poolName, size]) => { this.objectPool.set(poolName, { available: new Array(size), inUse: new Set(), size: size }); }); console.log('Object pooling enabled'); return poolConfig; }
                    configureGarbageCollection() { return { aggressiveCollection: true, collectionInterval: 30000, lowMemoryThreshold: 100, enableAutomaticCleanup: true, clearUnusedAssets: true, reduceHeapSize: true }; }
                    setTextureCompression() { return { useBC1: true, useBC4: true, useBC6H: true, useBASIS: true, reduceTextureResolution: true, targetResolution: 1024 }; }
                    optimizeAssets() { return { lazyLoading: true, streamingAssets: true, preloadCriticalAssets: true, unloadDistantAssets: true, unloadDistance: 500, useCompressedAudio: true, audioQuality: 'medium' }; }
                    getMemoryUsage() { if (typeof performance !== 'undefined' && performance.memory) { this.memoryUsage = (performance.memory.usedJSHeapSize / 1048576).toFixed(2); } return this.memoryUsage; }
                    forceGarbageCollection() { console.log('Forcing garbage collection...'); return { success: true, message: 'Garbage collection initiated' }; }
                    clearUnusedPools() { let cleared = 0; this.objectPool.forEach((pool, name) => { if (pool.inUse.size === 0) { pool.available = []; cleared++; } }); return { poolsCleared: cleared }; }
                    autoOptimizeMemory() { const usage = this.getMemoryUsage(); if (usage > 1024) { this.forceGarbageCollection(); this.clearUnusedPools(); return { action: 'aggressive_cleanup' }; } else if (usage > 700) { return { action: 'moderate_cleanup' }; } return { action: 'none' }; }
                    disableExpensiveFeatures() { return { disableMotionBlur: true, disableDepthOfField: true, disableChromaticAberration: true, disableDistortion: true, reduceShadowResolution: true, disableGlobalIllumination: true }; }
                }

                class BloodstrikeOptimizer {
                    constructor() { this.fpsOptimizer = null; this.latencyReducer = null; this.memoryOptimizer = null; this.settings = { maxFPS: 240, targetMS: 20, enableAll: false }; this.performanceMonitor = null; }
                    initAll() {
                        this.fpsOptimizer = new FPSOptimizer(); this.latencyReducer = new LatencyReducer(); this.memoryOptimizer = new MemoryOptimizer();
                        this.fpsOptimizer.init(); this.latencyReducer.init(); this.memoryOptimizer.init();
                        this.startPerformanceMonitoring(); console.log('All optimizations initialized');
                    }
                    startPerformanceMonitoring() {
                        if (this.performanceMonitor) return; // already running
                        this.performanceMonitor = setInterval(() => {
                            const fps = this.fpsOptimizer.monitorFPS(); this.latencyReducer.measurePing(); this.memoryOptimizer.autoOptimizeMemory();
                            if (fps < 30) this.reducedMode();
                        }, 1000);
                    }
                    stopMonitoring() { if (this.performanceMonitor) { clearInterval(this.performanceMonitor); this.performanceMonitor = null; } }
                    getPerformanceReport() { return { fps: { current: this.fpsOptimizer.getFPS(), target: this.settings.maxFPS }, latency: this.latencyReducer.getNetworkStats(), memory: { usage: this.memoryOptimizer.getMemoryUsage() + 'MB' }, timestamp: new Date().toISOString() }; }
                    reducedMode() { return { graphics: 'ultra-low', textures: 'compressed', shadows: 'off', particles: 'minimal', network: 'aggressive-sync' }; }
                    balancedMode() { return { graphics: 'medium', textures: 'compressed', shadows: 'low', particles: 'reduced', network: 'normal-sync' }; }
                    qualityMode() { return { graphics: 'high', textures: 'uncompressed', shadows: 'high', particles: 'full', network: 'normal-sync' }; }
                    emergencyMode() { this.memoryOptimizer.forceGarbageCollection(); this.fpsOptimizer.autoadjustQuality(); return { priority: 'fps-only', disableUI: true, minimizeNetwork: true, lowerResolution: true, targetFPS: 60 }; }
                    configure(options) { Object.assign(this.settings, options); return this.settings; }
                    printStatus() { const report = this.getPerformanceReport(); console.log('Status', report); }
                }
                // Make globally visible
                window.FPSOptimizer = FPSOptimizer;
                window.LatencyReducer = LatencyReducer;
                window.MemoryOptimizer = MemoryOptimizer;
                window.BloodstrikeOptimizer = BloodstrikeOptimizer;
                // ===== End Inlined Optimizers =====
        let optimizer = null;
        let monitoringActive = false;
        let uiInterval = null;

        function log(message) {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.className = 'line';
            line.textContent = `[${timestamp}] ${message}`;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }

        function initOptimizer() {
            log('üéÆ Initializing Bloodstrike Optimizer...');
            if (!optimizer) {
                optimizer = new BloodstrikeOptimizer();
                optimizer.initAll();
                log('‚úì FPS Optimizer initialized');
                log('‚úì Latency Reducer initialized');
                log('‚úì Memory Optimizer initialized');
                log('‚úì All systems ready!');
            } else {
                log('‚ö† Optimizer already initialized');
            }
        }

        function startMonitoring() {
            if (!optimizer) {
                log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.');
                return;
            }
            monitoringActive = true;
            log('üìä Performance monitoring started...');
            // Ensure internal monitoring loop runs
            optimizer.startPerformanceMonitoring();
            let counter = 0;
            if (uiInterval) clearInterval(uiInterval);
            uiInterval = setInterval(() => {
                const report = optimizer.getPerformanceReport();
                const fps = report.fps.current || 0;
                const ping = (report.latency && report.latency.currentPing) ? report.latency.currentPing : 0;
                const mem = (report.memory && report.memory.usage) ? report.memory.usage : '0MB';
                document.getElementById('fpsDisplay').textContent = fps;
                document.getElementById('msDisplay').textContent = ping + 'ms';
                document.getElementById('memDisplay').textContent = mem;
                counter++;
                if (counter % 5 === 0) {
                    log(`üìà FPS: ${fps} | MS: ${ping}ms | Memory: ${mem}`);
                }
                if (!monitoringActive && uiInterval) {
                    clearInterval(uiInterval);
                    uiInterval = null;
                }
            }, 200);
        }

        function stopMonitoring() {
            monitoringActive = false;
            if (uiInterval) { clearInterval(uiInterval); uiInterval = null; }
            if (optimizer) optimizer.stopMonitoring();
            log('‚èπÔ∏è Performance monitoring stopped.');
        }

        function setMode(mode) {
            if (!optimizer) { log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.'); return; }
            let settings = null;
            if (mode === 'reduced') settings = optimizer.reducedMode();
            else if (mode === 'balanced') settings = optimizer.balancedMode();
            else if (mode === 'quality') settings = optimizer.qualityMode();
            else if (mode === 'emergency') settings = optimizer.emergencyMode();
            log(`‚úì Switched to ${mode} mode ‚Äî ${JSON.stringify(settings)}`);
        }

        function measurePing() {
            if (!optimizer) { log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.'); return; }
            log('üì° Measuring ping...');
            optimizer.latencyReducer.measurePing((ping) => {
                log(`‚úì Current Ping: ${ping}ms`);
                const avg = optimizer.latencyReducer.getAveragePing();
                log(`‚úì Average Ping: ${avg}ms`);
                document.getElementById('msDisplay').textContent = ping + 'ms';
            });
        }

        function optimizeMemory() {
            if (!optimizer) { log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.'); return; }
            log('üíæ Optimizing memory...');
            const result = optimizer.memoryOptimizer.autoOptimizeMemory();
            log(`‚úì Memory optimization result: ${JSON.stringify(result)}`);
            document.getElementById('memDisplay').textContent = optimizer.memoryOptimizer.getMemoryUsage() + 'MB';
        }

        function forceGC() {
            if (!optimizer) { log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.'); return; }
            log('‚ôªÔ∏è Forcing garbage collection...');
            const res = optimizer.memoryOptimizer.forceGarbageCollection();
            log(`‚úì ${res.message}`);
        }

        function clearPools() {
            if (!optimizer) { log('‚ö†Ô∏è Optimizer not initialized. Run Initialize first.'); return; }
            log('üóëÔ∏è Clearing unused object pools...');
            const res = optimizer.memoryOptimizer.clearUnusedPools();
            log(`‚úì ${res.poolsCleared} pools cleared`);
        }

        // Initial message
        window.onload = function() {
            log('üéÆ Bloodstrike Optimizer Ready');
            log('Click "Initialize Optimizer" to begin');
        };
    </script>
</body>
</html>
